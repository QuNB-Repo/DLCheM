{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'energy_U0': None}\n"
     ]
    }
   ],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "\"\"\"\n",
    "Spyder Editor\n",
    "\n",
    "This is a temporary script file.\n",
    "\"\"\"\n",
    "\n",
    "import os\n",
    "import schnetpack as spk\n",
    "import torch\n",
    "import schnetpack.nn \n",
    "import schnetpack.data\n",
    "\n",
    "\n",
    "qm9tut = './qm9tut'\n",
    "if not os.path.exists('qm9tut'):\n",
    "    os.makedirs(qm9tut)\n",
    "    \n",
    "from schnetpack.datasets import QM9\n",
    "\n",
    "qm9data = QM9('./qm9.db', download=True, load_only=[QM9.U0], remove_uncharacterized=True)\n",
    "\n",
    "train, val, test = spk.train_test_split(\n",
    "        data=qm9data,\n",
    "        num_train=1000,\n",
    "        num_val=500,\n",
    "        split_file=os.path.join(qm9tut, \"split.npz\"),\n",
    "    )\n",
    "\n",
    "train_loader = spk.AtomsLoader(train, batch_size=100, shuffle=True)\n",
    "val_loader = spk.AtomsLoader(val, batch_size=100)\n",
    "\n",
    "atomrefs = qm9data.get_atomref(QM9.U0)\n",
    "print(atomrefs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "'NoneType' object is not subscriptable",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-12-4239200f578e>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'U0 of hyrogen:'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'{:.2f}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0matomrefs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mQM9\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mU0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'eV'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'U0 of carbon:'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'{:.2f}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0matomrefs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mQM9\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mU0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m6\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'eV'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'U0 of oxygen:'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'{:.2f}'\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0matomrefs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mQM9\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mU0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m8\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'eV'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: 'NoneType' object is not subscriptable"
     ]
    }
   ],
   "source": [
    "print('U0 of hyrogen:', '{:.2f}'.format(atomrefs[QM9.U0][1][0]), 'eV')\n",
    "print('U0 of carbon:', '{:.2f}'.format(atomrefs[QM9.U0][6][0]), 'eV')\n",
    "print('U0 of oxygen:', '{:.2f}'.format(atomrefs[QM9.U0][8][0]), 'eV')\n",
    "\n",
    "\n",
    "means, stddevs = train_loader.get_statistics(\n",
    "    QM9.U0, divide_by_atoms=True, single_atom_ref=atomrefs)\n",
    "\n",
    "\n",
    "print('Mean atomization energy / atom:', means[QM9.U0])\n",
    "print('Std. dev. atomization energy / atom:', stddevs[QM9.U0])\n",
    "\n",
    "\n",
    "\n",
    "schnet = spk.representation.SchNet(\n",
    "    n_atom_basis=30, n_filters=30, n_gaussians=20, n_interactions=5,\n",
    "    cutoff=4., cutoff_network=spk.nn.cutoff.CosineCutoff\n",
    ")\n",
    "\n",
    "output_U0 = spk.atomistic.Atomwise(n_in=30, atomref=atomrefs[QM9.U0], property=QM9.U0,\n",
    "                                   mean=means[QM9.U0], contributions=True, stddev=stddevs[QM9.U0])\n",
    "model = spk.AtomisticModel(representation=schnet, output_modules=output_U0)\n",
    "\n",
    "\n",
    "from torch.optim import Adam\n",
    "\n",
    "# loss function\n",
    "def mse_loss(batch, result):\n",
    "    diff = batch[QM9.U0]-result[QM9.U0]\n",
    "    err_sq = torch.mean(diff ** 2)\n",
    "    return err_sq\n",
    "\n",
    "# build optimizer\n",
    "optimizer = Adam(model.parameters(), lr=1e-2)\n",
    "\n",
    "\n",
    "# before setting up the trainer, remove previous training checkpoints and logs\n",
    "\n",
    "## AFter your first run figure out how to remove checkpoint and log file\n",
    "\n",
    "import schnetpack.train as trn\n",
    "\n",
    "loss = trn.build_mse_loss([QM9.U0])\n",
    "\n",
    "metrics = [spk.metrics.MeanAbsoluteError(QM9.U0)]\n",
    "hooks = [\n",
    "    trn.CSVHook(log_path=qm9tut, metrics=metrics),\n",
    "    trn.ReduceLROnPlateauHook(\n",
    "        optimizer,\n",
    "        patience=5, factor=0.8, min_lr=1e-6,\n",
    "        stop_after_min=True\n",
    "    )\n",
    "]\n",
    "\n",
    "trainer = trn.Trainer(\n",
    "    model_path=qm9tut,\n",
    "    model=model,\n",
    "    hooks=hooks,\n",
    "    loss_fn=loss,\n",
    "    optimizer=optimizer,\n",
    "    train_loader=train_loader,\n",
    "    validation_loader=val_loader,\n",
    ")\n",
    "\n",
    "device = \"cpu\" # change to 'cpu' if gpu is not available\n",
    "n_epochs = 300 # takes about 10 min on a notebook GPU. reduces for playing around\n",
    "trainer.train(device=device, n_epochs=n_epochs)\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from ase.units import kcal, mol\n",
    "\n",
    "results = np.loadtxt(os.path.join(qm9tut, 'log.csv'), skiprows=1, delimiter=',')\n",
    "\n",
    "time = results[:,0]-results[0,0]\n",
    "learning_rate = results[:,1]\n",
    "train_loss = results[:,2]\n",
    "val_loss = results[:,3]\n",
    "val_mae = results[:,4]\n",
    "\n",
    "print('Final validation MAE:', np.round(val_mae[-1], 2), 'eV =',\n",
    "      np.round(val_mae[-1] / (kcal/mol), 2), 'kcal/mol')\n",
    "\n",
    "plt.figure(figsize=(14,5))\n",
    "plt.subplot(1,2,1)\n",
    "plt.plot(time, val_loss, label='Validation')\n",
    "plt.plot(time, train_loss, label='Train')\n",
    "plt.yscale('log')\n",
    "plt.ylabel('Loss [eV]')\n",
    "plt.xlabel('Time [s]')\n",
    "plt.legend()\n",
    "plt.subplot(1,2,2)\n",
    "plt.plot(time, val_mae)\n",
    "plt.ylabel('mean abs. error [eV]')\n",
    "plt.xlabel('Time [s]')\n",
    "plt.show()\n",
    "\n",
    "import xlwt\n",
    "from xlwt import Workbook\n",
    "\n",
    "wb = Workbook()\n",
    "sheet1 = wb.add_sheet('Sheet1')\n",
    "\n",
    "best_model = torch.load(os.path.join(qm9tut, 'best_model'))\n",
    "for idx in range(500):\n",
    "\n",
    "    test_loader = spk.AtomsLoader(test, batch_size=100)\n",
    "    converter = spk.data.AtomsConverter(device=device)\n",
    "    at, props = qm9data.get_properties(idx)\n",
    "\n",
    "    x = props['_positions'][ :,0]\n",
    "    y = props['_positions'][ :,1]\n",
    "    z = props['_positions'][ :,2]\n",
    "\n",
    "\n",
    "    inputs = converter(at)\n",
    "    print('Keys:', list(inputs.keys()))\n",
    "    print('Truth:', props[QM9.U0].cpu().numpy()[0])\n",
    "\n",
    "    calculator = spk.interfaces.SpkCalculator(model=model, device=device, energy=QM9.U0)\n",
    "    at.set_calculator(calculator)\n",
    "\n",
    "\n",
    "    print('Prediction:', at.get_total_energy())\n",
    "\n",
    "\n",
    "    from ase.io import read\n",
    "\n",
    "    atoms = read('./mydata1.xyz', index=':11')\n",
    "    print('Energy:', atoms[3].info)\n",
    "    print()\n",
    "\n",
    "#property_list = []\n",
    "#for at in atoms:\n",
    "    # All properties need to be stored as numpy arrays.\n",
    "    # Note: The shape for scalars should be (1,), not ()\n",
    "    # Note: GPUs work best with float32 data\n",
    "#    energy = np.array([float(list(at.info.keys())[0])], dtype=np.float32)\n",
    "#    property_list.append(\n",
    "#        {'energy': energy}\n",
    "#    )\n",
    "\n",
    "#print('Properties:', property_list)\n",
    "\n",
    "#from schnetpack import AtomsData\n",
    "\n",
    "#new_dataset = AtomsData('/home/amerelsamman/Desktop/Experiments/SchNet/mydata.db', available_properties=['energy'])\n",
    "#new_dataset.add_systems(atoms, property_list)\n",
    "\n",
    "#converter = spk.data.AtomsConverter(device=device)\n",
    "#at2, props2 = new_dataset.get_properties(0)\n",
    "\n",
    "#calculator = spk.interfaces.SpkCalculator(model=model, device=device, energy=QM9.U0)\n",
    "#at2.set_calculator(calculator)\n",
    "#print('Prediction:', at2.get_total_energy())\n",
    "\n",
    "\n",
    "    from mpl_toolkits import mplot3d\n",
    "\n",
    "    import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "#    ax = plt.axes(projection='3d')\n",
    "\n",
    "# Data for three-dimensional scattered points\n",
    "#   for i in range(len(z)):\n",
    "#       zdata = z[i]\n",
    "#       xdata = y[i]\n",
    "#       ydata = x[i]\n",
    "#       atomicnumbers = props['_atomic_numbers'][i]\n",
    "#       if atomicnumbers == 6:\n",
    "#           c = 'g'\n",
    "#       if atomicnumbers == 1:\n",
    "#           c = 'b'\n",
    "#       if atomicnumbers == 7:\n",
    "#          c = 'y'\n",
    "#       if atomicnumbers == 8:\n",
    "#           c = 'r'\n",
    "#   ax.scatter3D(xdata, ydata, zdata, c=c)\n",
    "#   ax.set_xlabel('X Label')\n",
    "#   ax.set_ylabel('Y Label')\n",
    "#   ax.set_zlabel('Z Label')\n",
    "#   plt.show()\n",
    "    from schnetpack.atomistic import output_modules\n",
    "\n",
    "    atomenergies = (output_modules.yi)\n",
    "\n",
    "    atomenergies = atomenergies.detach().numpy()\n",
    "    print(atomenergies)\n",
    "\n",
    "    numH = 0\n",
    "    numC = 0\n",
    "    numN = 0\n",
    "    numO = 0\n",
    "    h=0\n",
    "    c=0\n",
    "    n=0\n",
    "    o=0\n",
    "    for i in range(len(z)):\n",
    "        atomicnumbers = props['_atomic_numbers'][i]\n",
    "        if atomicnumbers == 1:\n",
    "            numH = numH + atomenergies[0,i]\n",
    "            h = h +1\n",
    "        if atomicnumbers == 6:\n",
    "            numC = numC + atomenergies[0,i]\n",
    "            c = c +1\n",
    "        if atomicnumbers == 7:\n",
    "            numN = numN + atomenergies[0,i]\n",
    "            n = n+1\n",
    "        if atomicnumbers == 8:\n",
    "            numO = numO + atomenergies[0,i]\n",
    "            o = o + 1\n",
    "        if numH != 0:\n",
    "            aveH = numH/h\n",
    "        else:\n",
    "            aveH = -13.61312\n",
    "        if numC != 0:\n",
    "            aveC = numC/c\n",
    "        else:\n",
    "            aveC = -1029.86302\n",
    "        if numN != 0:\n",
    "            aveN = numN/n\n",
    "        else:\n",
    "            aveN = -1485.302400 \n",
    "        if numO != 0:\n",
    "            aveO = numO/o\n",
    "        else:\n",
    "            aveO = -2042.6110546\n",
    "\n",
    "    print(aveC)\n",
    "    print(aveH)\n",
    "    print(aveN)\n",
    "    print(aveO)\n",
    "    aveH = float(aveH)\n",
    "    aveC = float(aveC)\n",
    "    aveN = float(aveN)\n",
    "    aveO = float(aveO)\n",
    "    sheet1.write(idx,0, aveH)\n",
    "    sheet1.write(idx,1, aveC)\n",
    "#    sheet1.write(idx,2, aveN)\n",
    "#    sheet1.write(idx,3, aveO)    \n",
    "    wb.save('./pca/automated-pca.xls')\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
